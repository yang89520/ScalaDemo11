# JavaSE_day02【数据类型转换、运算符】
{: id="20210309181757-wk7lltw"}

## 今日内容
{: id="20210309181757-gj0bj9q"}

- {: id="20210309181757-k6a842b"}数据类型
  {: id="20210309181757-ib8tujp"}
- {: id="20210309181757-i48b3jl"}运算符
  {: id="20210309181757-08sa11c"}
{: id="20210309181757-ft74kn1"}

## 学习目标
{: id="20210309181757-vhbqztb"}

- {: id="20210309181757-uonp6oq"}[ ] 了解进制
  {: id="20210309181757-0duwzm7"}
- {: id="20210309181757-1oq0gmb"}[ ] 理解基本数据类型的自动类型转换
  {: id="20210309181757-ux7vhtz"}
- {: id="20210309181757-14i7sqd"}[ ] 理解基本数据类型的强制类型转换
  {: id="20210309181757-4vgyraw"}
- {: id="20210309181757-uxw0ik5"}[ ] 了解ASCII编码表和Unicode编码表
  {: id="20210309181757-otnt8bj"}
- {: id="20210309181757-rvfsnr6"}[ ] 理解int类型和char类型的运算原理
  {: id="20210309181757-8334oa0"}
- {: id="20210309181757-36bjk6r"}[ ] 理解运算符++ --的运算方式
  {: id="20210309181757-nllftdo"}
- {: id="20210309181757-kmijfm6"}[ ] 理解+符号在字符串中的作用
  {: id="20210309181757-j745wup"}
- {: id="20210309181757-v09x38n"}[ ] 掌握算术运算符
  {: id="20210309181757-652h1lm"}
- {: id="20210309181757-gj7ph8k"}[ ] 掌握赋值运算符
  {: id="20210309181757-dpqoydk"}
- {: id="20210309181757-9fatwck"}[ ] 掌握比较运算符
  {: id="20210309181757-o38ob3w"}
- {: id="20210309181757-i6u86g4"}[ ] 理解逻辑运算符
  {: id="20210309181757-yijh1rz"}
- {: id="20210309181757-kjbltc3"}[ ] 掌握三元运算符的格式和计算结果
  {: id="20210309181757-v1fdhjx"}
- {: id="20210309181757-4g7jajy"}[ ] 了解位运算符
  {: id="20210309181757-mmxvnvq"}
{: id="20210309181757-ce3mo55"}

# 第二章 Java基础知识（续）
{: id="20210309181757-y57rbln"}

## 2.8  计算机如何存储数据
{: id="20210309181757-trkwdnd"}

计算机世界中只有二进制。那么在计算机中存储和运算的所有数据都要转为二进制。包括数字、字符、图片、声音、视频等。
{: id="20210309181757-7lx4ff8"}

### 2.8.1 进制（了解）
{: id="20210309181757-otf1gce"}

#### 1、进制的分类
{: id="20210309181757-1bhks0j"}

（1）十进制：
数字组成：0-9
进位规则：逢十进一
{: id="20210309181757-wn5errg"}

（2）二进制：
数字组成：0-1
进位规则：逢二进一
{: id="20210309181757-5ym9z7p"}

十进制的256，二进制：100000000，为了缩短二进制的表示，又要贴近二进制，在程序中引入八进制和十六进制
{: id="20210309181757-l05mdf6"}

（3）八进制：很少使用
数字组成：0-7
进位规则：逢八进一
{: id="20210309181757-po428x0"}

与二进制换算规则：每三位二进制是一位八进制值
{: id="20210309181757-5pwc6eh"}

（4）十六进制
数字组成：0-9，a-f
进位规则：逢十六进一
{: id="20210309181757-c8ytfey"}

与二进制换算规则：每四位二进制是一位十六进制值
{: id="20210309181757-bpvxta1"}

#### 2、进制的换算
{: id="20210309181757-33nu216"}

| 十进制 | 二进制 | 八进制 | 十六进制 |
| ------ | ------ | ------ | -------- |
| 0      | 0      | 0      | 0        |
| 1      | 1      | 1      | 1        |
| 2      | 10     | 2      | 2        |
| 3      | 11     | 3      | 3        |
| 4      | 100    | 4      | 4        |
| 5      | 101    | 5      | 5        |
| 6      | 110    | 6      | 6        |
| 7      | 111    | 7      | 7        |
| 8      | 1000   | 10     | 8        |
| 9      | 1001   | 11     | 9        |
| 10     | 1010   | 12     | a或A     |
| 11     | 1011   | 13     | b或B     |
| 12     | 1100   | 14     | c或C     |
| 13     | 1101   | 15     | d或D     |
| 14     | 1110   | 16     | e或E     |
| 15     | 1111   | 17     | f或F     |
| 16     | 10000  | 20     | 10       |
{: id="20210309181757-c7ksbaj"}

- {: id="20210309181757-2gu0x46"}**十进制数据转成二进制数据：**使用除以2倒取余数的方式
  ![](img/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.jpg)
  {: id="20210309181757-0cy4ah7"}
- {: id="20210309181757-2as7zvm"}**二进制数据转成十进制数据：**
  {: id="20210309181757-wdli8fk"}
  从右边开始依次是2的0次，2的1次，2的2次。。。。
  {: id="20210309181757-z4l5xm8"}
  ![](img/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6.jpg)
  {: id="20210309181757-h7znwkt"}
- {: id="20210309181757-e525dpi"}二进制数据转八进制数据
  {: id="20210309181757-6vwpont"}
  ​	从右边开始，三位一组
  {: id="20210309181757-7xfhrqt"}
  ![](img/2、二进制与八进制转换.png)
  {: id="20210309181757-avvr9ee"}
- {: id="20210309181757-0q70q2u"}二进制数据转十六进制数据
  {: id="20210309181757-b8dnovw"}
  ​	从右边开始，四位一组
  {: id="20210309181757-bwtlq7b"}
  ![](img/3、二进制与十六进制转换.png)
  {: id="20210309181757-bed1iil"}
{: id="20210309181757-wk7fy8b"}

#### 3、在代码中如何表示四种进制的值
{: id="20210309181757-uha2c2j"}

请分别用四种类型的进制来表示10，并输出它的结果：（了解）
{: id="20210309181757-j5jzr2f"}

（1）十进制：正常表示（==计算机上正常运行都是十进制，只有底层才是采用二进制==）
{: id="20210309181757-na4wx39"}

System.out.println(10);
{: id="20210309181757-36pnhhr"}

（2）二进制：0b或0B开头
{: id="20210309181757-k2vkvh1"}

System.out.println(0B10);
{: id="20210309181757-so2401l"}

（3）八进制：0开头
{: id="20210309181757-l67wl3a"}

System.out.println(010);
{: id="20210309181757-iw24fb2"}

（4）十六进制：0x或0X开头
{: id="20210309181757-u38uj6y"}

System.out.println(0X10);
{: id="20210309181757-x5ofbb5"}

### 2.8.2 计算机存储单位
{: id="20210309181757-9y2c1sa"}

- {: id="20210309181757-7vzjgi5"}**字节（Byte）：**是计算机信息技术用于计量存储容量的一种计量单位，一字节等于八位。
  {: id="20210309181757-7faw4kr"}
- {: id="20210309181757-1h3lyew"}**位（bit）：**是数据存储的最小单位。也就是二进制。二进制数系统中，每个0或1就是一个位，叫做bit（比特），其中8 bit 就称为一个字节(Byte)。
  {: id="20210309181757-ve14pnr"}
- {: id="20210309181757-371n9f1"}**转换关系：**
  {: id="20210309181757-qfewrti"}
  - {: id="20210309181757-3affm97"}8 bit = 1 Byte
    {: id="20210309181757-8x2fwxs"}
  - {: id="20210309181757-rhvkhu1"}1024 Byte = 1 KB
    {: id="20210309181757-hdtt64c"}
  - {: id="20210309181757-ii6jzqp"}1024 KB = 1 MB
    {: id="20210309181757-f6im8ld"}
  - {: id="20210309181757-h9e5n12"}1024 MB = 1 GB
    {: id="20210309181757-enrzzfy"}
  - {: id="20210309181757-0oq4gdv"}1024 GB = 1 TB
    {: id="20210309181757-8ddfu4j"}
  {: id="20210309181757-clekd97"}
{: id="20210309181757-52okrwi"}

### 2.8.3 Java的基本数据类型的存储范围
{: id="20210309181757-8n9bdlb"}

#### 1、整型系列
{: id="20210309181757-4j563ft"}

（1）byte：字节类型
{: id="20210309181757-po1u7c4"}

* {: id="20210309181757-bcpbhxi"}占内存：1个字节
  {: id="20210309181757-t74ilpx"}
* {: id="20210309181757-k6n7fn4"}存储范围：-128~127
  {: id="20210309181757-fxg6xvr"}
{: id="20210309181757-sykwm2l"}

（2）short：短整型类型
{: id="20210309181757-w2sigwe"}

* {: id="20210309181757-604ia5i"}占内存：2个字节
  {: id="20210309181757-06srgq6"}
* {: id="20210309181757-g9arw4c"}存储范围：-32768~32767
  {: id="20210309181757-sow9yxo"}
{: id="20210309181757-l5do7jl"}

（3）int：整型
{: id="20210309181757-smb0hxy"}

* {: id="20210309181757-ykbdhpi"}占内存：4个字节
  {: id="20210309181757-594phwt"}
* {: id="20210309181757-77s2zc1"}存储范围：-2的31次方 ~ 2的31次方-1
  {: id="20210309181757-6la725x"}
{: id="20210309181757-gfj03ku"}

（4）long：整型
{: id="20210309181757-8m3q5b6"}

* {: id="20210309181757-ain66vp"}占内存：8个字节
  {: id="20210309181757-119b3i4"}
* {: id="20210309181757-34t53i0"}存储范围：-2的63次方 ~ 2的63次方-1
  {: id="20210309181757-asi0gze"}
{: id="20210309181757-97i5qwg"}

> 注意：如果要表示某个超过int范围的常量整数它是long类型，那么需要在数字后面加L
> {: id="20210309181757-4y2ek44"}
{: id="20210309181757-sefh8ai"}

#### 2、浮点型系列（小数）
{: id="20210309181757-7fvftpj"}

（1）float：单精度浮点型
{: id="20210309181757-0i17ko1"}

* {: id="20210309181757-05p32kg"}占内存：4个字节
  {: id="20210309181757-6ich892"}
* {: id="20210309181757-gbdftt6"}精度：科学记数法的小数点后6~7位
  {: id="20210309181757-jprlga8"}
{: id="20210309181757-a4lzb3k"}

> ==注意：如果要表示某个常量小数是float类型，那么需要在数字后面加F或f，否则就是double类型==
> {: id="20210309181757-bzeek9j"}
{: id="20210309181757-1w9vxdq"}

（2）double：双精度浮点型
{: id="20210309181757-qy2ani8"}

* {: id="20210309181757-0u7ffr1"}占内存：8个字节
  {: id="20210309181757-j3wkh7j"}
* {: id="20210309181757-zg9i8st"}精度：科学记数法的小数点后15~16位
  {: id="20210309181757-djrdqya"}
{: id="20210309181757-al75yte"}

```java
float f = 12.0F;//右边如果赋值小数常量值，那么必须加F或f
```
{: id="20210309181757-oxgle2l"}

#### 3、单字符类型：char
{: id="20210309181757-za8xh7t"}

* {: id="20210309181757-anxrfns"}占内存：2个字节（==字符码只有正数是因为三码合一，查寻方便==）
  {: id="20210309181757-2t4fru4"}
{: id="20210309181757-36y4ryl"}

#### 4、布尔类型
{: id="20210309181757-akl4y87"}

boolean：只能存储true或false，占内存：1个字节。
{: id="20210309181757-b1npiz6"}

> 虽然计算机底层使用0和1表示false和true，但是在代码中不能给boolean类型的变量赋值0和1，只能赋值false和true
> {: id="20210309181757-i04czpq"}
{: id="20210309181757-tit91k6"}

### 2.8.4 计算机如何存储数据
{: id="20210309181757-uqg01dn"}

#### 1、补码与符号位
{: id="20210309181757-75jsjkp"}

*计算机数据的存储使用二进制补码形式存储，并且最高位是符号位，1是负数，0是正数。*
{: id="20210309181757-n5i5kbm"}

*规定：正数的补码与反码、原码一样，称为三码合一；*
{: id="20210309181757-jk49qgx"}

​	    *负数的补码与反码、原码不一样：*
{: id="20210309181757-h1p4z3x"}

​	   *负数的原码：把十进制转为二进制，然后最高位设置为1*
{: id="20210309181757-l43o139"}

​	   *负数的反码：在原码的基础上，最高位不变，其余位取反（0变1,1变0）*
{: id="20210309181757-jsb96zr"}

​	   *负数的补码：反码+1*
{: id="20210309181757-h9altf9"}

*例如：byte类型（1个字节，8位）*
{: id="20210309181757-tlypbid"}

*25 ==> 原码  0001 1001 ==> 反码  0001 1001 -->补码  0001 1001*
{: id="20210309181757-3gzuuc3"}

*-25 ==>原码  1001 1001 ==> 反码1110 0110 ==>补码 1110 0111*
{: id="20210309181757-mv9no9d"}

底层是用加法代替减法：-128》-127-1》-127+(-1)
{: id="20210309181757-3iflq29"}

​				       -127- -1 ==> -127 + 1
{: id="20210309181757-9t996do"}

#### 2、一个字节可以存储的数据范围是多少？
{: id="20210309181757-799ouyq"}

（1）无符号：不考虑正负数
{: id="20210309181757-lnby2e3"}

（2）有符号
{: id="20210309181757-z5050y6"}

1个字节：8位
{: id="20210309181757-ymd949n"}

0000 0001  ~  0111 1111 ==> 1~127
{: id="20210309181757-z3i7tli"}

1000 0001 ~ 1111 1111 ==> -127 ~ -1
{: id="20210309181757-k2e2y0s"}

0000 0000 ==>0
{: id="20210309181757-wap7ic1"}

1000 0000 ==> -128（特殊规定）
{: id="20210309181757-d9y5s2l"}

#### 3、如何存储小数
{: id="20210309181757-2yv1424"}

* {: id="20210309181757-f6uarkm"}为什么float（4个字节）比long（8个字节）的存储范围大？
  {: id="20210309181757-sgs1sbh"}
* {: id="20210309181757-8uvp4hj"}为什么double（8个字节）比float（4个字节）精度范围大？
  {: id="20210309181757-32mn2rv"}
* {: id="20210309181757-yo0uzxk"}为什么float和double不精确
  {: id="20210309181757-0oq9yfv"}
{: id="20210309181757-wrifb4l"}

因为float、double底层也是二进制，先把小数转为二进制，然后把二进制表示为科学记数法，然后只保存：
{: id="20210309181757-eq32wt6"}

①符号位②指数位③尾数位
{: id="20210309181757-6rljw7k"}

> *详见《float型和double型数据的存储方式.docx》*
> {: id="20210309181757-tqkdx1g"}
{: id="20210309181757-0q4xknf"}

#### 4、如何存储字符
{: id="20210309181757-txflo8j"}

* {: id="20210309181757-zclnotx"}Java中使用的字符集：Unicode编码集
  {: id="20210309181757-r5fo8yp"}
{: id="20210309181757-qn19llz"}

##### 编码表
{: id="20210309181757-18pds77"}

在计算机的内部都是二进制的0、1数据，如何让计算机可以直接识别人类文字的问题呢？就产生出了编码表的概念。**编码表** ：就是将人类的文字和一个十进制数进行对应起来组成一张表格。例如：
{: id="20210309181757-a3ph0vd"}

| 字符 | 数值 |
| :--: | :--: |
|  0  |  48  |
|  A  |  65  |
|  a  |  97  |
{: id="20210309181757-pluh3vj"}

将所有的英文字母，数字，符号都和十进制进行了对应，因此产生了世界上第一张编码表ASCII（American Standard Code for Information Interchange 美国标准信息交换码）。
{: id="20210309181757-5647ufb"}

Unicode(统一码、万国码、单一码)是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。
{: id="20210309181757-l10s2wy"}

##### 字符常量的几种表示方式
{: id="20210309181757-xbmz7nb"}

（1）'一个字符'
{: id="20210309181757-utbaies"}

例如：'A'，'0'，'尚'
{: id="20210309181757-zzem10v"}

（2）转义字符
{: id="20210309181757-78f58ed"}

```
\n：换行
\r：回车
\t：Tab键
\\：\
\"："
\'：'
\b：删除键Backspace

System.out.println('\\');
System.out.println("hello\tworld\njava");
```
{: id="20210309181757-oboo4e0"}

（3）\u字符的Unicode编码值的十六进制型
{: id="20210309181757-p6sryr1"}

例如：'\u5c1a'代表'尚'
{: id="20210309181757-logjkol"}

```java
		char c = '\u5c1a';
		char c = '尚';
		String s = '尚';//错误的，哪怕是一个字符，也要使用双引号
		
		char c2 = '';//错误，单引号中有且只能有一个字符
		String s2 = "";//可以，双引号中可以没有其他字符，表示是空字符串
```
{: id="20210309181757-85909jl"}

（4）直接给char类型变量赋值十进制的0~65535之间的Unicode编码值
{: id="20210309181757-zfgrhut"}

例如：'尚' 的编码值是23578
{: id="20210309181757-w7yk0g6"}

​	   'a'的编码值是97
{: id="20210309181757-3i3lc7s"}

```java
char c1 = 23578;
System.out.println(c1);//尚

char c2 = 97;
System.out.println(c2);//a
```
{: id="20210309181757-ir297p8"}

## 2.9  基本数据类型转换（Conversion）
{: id="20210309181757-b2tolle"}

在Java程序中，不同的基本数据类型的值经常需要进行相互转换。Java语言所提供的**七种数值类型**之间可以相互转换，基本数据类型转换有两种转换方式：自动类型转换和强制类型转换。
{: id="20210309181757-0v2iyxm"}

#### 1、自动类型转换（隐式类型转换）
{: id="20210309181757-hy1jikt"}

**自动转换**：
{: id="20210309181757-8jfk0hc"}

* {: id="20210309181757-u32myic"}将`取值范围小的类型`自动提升为`取值范围大的类型` 。
  {: id="20210309181757-2gbjggj"}
{: id="20210309181757-ie674a2"}

基本数据类型的转换规则
{: id="20210309181757-xl535kc"}

小结：通过上面案例我们可以得出数据类型的转换关系（取值范围从小到大），如图所示：
{: id="20210309181757-mhi6ti5"}

![](img\自动类型转换图1.jpg)
{: id="20210309181757-y0dvni6"}

（1）当把存储范围小的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围大的变量时，==（java程序规定在计算之前必须进类型同一）==
{: id="20210309181757-3zrwddl"}

```java
int i = 'A';//char自动升级为int
double d = 10;//int自动升级为double

byte b = 127; //右边的整数常量值必须在-128~127范围内
//byte bigB = 130;//错误，右边的整数常量值超过byte范围
long num = 1234567; //右边的整数常量值如果在int范围呢，编译和运行都可以通过，这里涉及到数据类型转换
long bigNum = 12345678912L;//右边的整数常量值如果超过int范围，必须加L，否则编译不通过
```
{: id="20210309181757-xu3n3eg"}

（2）当存储范围小的数据类型与存储范围大的数据类型一起混合运算时，会按照其中最大的类型运算
{: id="20210309181757-c4breie"}

```java
int i = 1;
byte b = 1;
double d = 1.0;

double sum = i + b + d;//混合运算，升级为double
```
{: id="20210309181757-1do3oqe"}

（3）当byte,short,char数据类型进行算术运算时，按照int类型处理
{: id="20210309181757-sd39pj2"}

```java
byte b1 = 1;
byte b2 = 2;
byte b3 = b1 + b2;//编译报错，b1 + b2自动升级为int

char c1 = '0';
char c2 = 'A';
System.out.println(c1 + c2);//113 
```
{: id="20210309181757-0pzh9gu"}

（4）boolean类型不参与
{: id="20210309181757-3hpsgsb"}

#### 2、强制类型转换（显示类型转换）
{: id="20210309181757-cfjkl2o"}

将`1.5` 赋值到`int` 类型变量会发生什么？产生编译失败，肯定无法赋值。
{: id="20210309181757-svf8ekl"}

```java
int i = 3.14; // 错误
```
{: id="20210309181757-fcjt7sp"}

想要赋值成功，只有通过强制类型转换，将`double` 类型强制转换成`int` 类型才能赋值。
{: id="20210309181757-0aqfgod"}

* {: id="20210309181757-2b13gzp"}**强制类型转换**：将`取值范围大的类型`强制转换成`取值范围小的类型`。
  {: id="20210309181757-ast318l"}
{: id="20210309181757-1cj3wio"}

比较而言，自动转换是Java自动执行的，而强制转换需要我们自己手动执行。
{: id="20210309181757-ykbu7ea"}

**转换格式：**
{: id="20210309181757-qpckgx3"}

```java
数据类型 变量名 = （数据类型）被强转数据值；
```
{: id="20210309181757-9q5gcs8"}

（1）当把存储范围大的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围小的变量时，需要强制类型转换，==提示：强制类型转换有风险，可能会损失精度或溢出，转结果比转变量更精确==
{: id="20210309181757-xmif8g3"}

```java
int i = (int)3.14;//强制类型转换，损失精度

double d = 1.2;
int num = (int)d;//损失精度

int i = 200;
byte b = (byte)i;//溢出
```
{: id="20210309181757-zw5r75s"}

（2）boolean类型不参与
{: id="20210309181757-0l9dgq1"}

（3）当某个值想要提升数据类型时，也可以使用强制类型转换
{: id="20210309181757-sx8yz9w"}

```java
int i = 1;
int j = 2;
double shang = (double)i/j;
```
{: id="20210309181757-5byfs5c"}

提示：这个情况的强制类型转换是没有风险的。
{: id="20210309181757-mv32sn9"}

#### 3、特殊的数据类型转换
{: id="20210309181757-s5ldfm0"}

1、==任意数据类型的数据与String类型进行“+”运算时，结果一定是String类型，String不能修改运算的优先级==
{: id="20210309181757-jc9ss7s"}

```java
System.out.println("" + 1 + 2);//12
```
{: id="20210309181757-wz5hx5d"}

2、但是String类型不能通过强制类型()转换，转为其他的类型
{: id="20210309181757-l0yqm3a"}

```java
String str = "123";
int num = (int)str;//错误的
int num = Integer.parseInt(str);//后面才能讲到，借助包装类的方法才能转
```
{: id="20210309181757-yf8idiz"}

#### 4、练习
{: id="20210309181757-79nggh3"}

```java
1、练习题：判断如下代码是否编译通过，如果能，结果是多少？
short s1 = 120;//java在运行计算整数的时候是按照默认的int类型的，算完后根据域调整。
short s2 = 8;
short s3 = s1 + s2;

2、练习题：判断如下代码是否编译通过，如果能，结果是多少？
short s1 = 120;
short s2 = 8;
byte s3 = (byte)(s1 + s2);

3、练习题：判断如下代码是否编译通过，如果能，结果是多少？
char c1 = '0';
char c2 = '1';
char c3 = c1 + c2;

4、练习题：判断如下代码是否编译通过，如果能，结果是多少？（//通过Unicode值计算）
char c1 = '0';
char c2 = '1';
System.out.println(c1 + c2);

5、练习题：判断如下代码是否编译通过，如果能，结果是多少？
int i = 4;
long j = 120; //因为右边120默认是int类型，int的值赋值给long类型是可以的，会自动类型转换，但是要求这个int值不能超过int的存储范围，如果超过int的存储范围必须加L.
double d = 34;
float f = 1.2;//因为右边1.2默认是double类型，double的值是不能直接赋值给float的，要么加F要么使用强制类型转换。

System.out.println(i + j + d + f);//最后是double

6、练习题：判断如下代码是否编译通过，如果能，结果是多少？
int i = 1;
int j = 2;
double d = i/j;
System.out.println(d);
```
{: id="20210309181757-98ap5ln"}

## 2.10 运算符（Operator）
{: id="20210309181757-7acjnik"}

* {: id="20210309181757-i5dnoyt"}表达式：用运算符连接起来的式子
  {: id="20210309181757-avyo14t"}
* {: id="20210309181757-wobleka"}运算符的分类：
  按照功能分：算术运算符、赋值运算符、比较运算符、逻辑运算、条件运算符...
  {: id="20210309181757-x8qs6co"}
{: id="20210309181757-jejqdb5"}

|       分类       |               运算符               |
| :--------------: | :---------------------------------: |
|    算术运算符    | `+`、`-`、`*`、`/`、`%`、`++`、`--` |
|    赋值运算符    | `=`、`+=`、`-=`、`*=`、`/=`、`%=`等 |
|    关系运算符    |  `>`、`>=`、`<`、`<=`、`==`、`!=`  |
|    逻辑运算符    |               `&`、`               |
|    条件运算符    |    `(条件表达式)?结果1:结果2；`    |
| 位运算符（了解） |               `&`、`               |
{: id="20210309181757-hxmtzru"}

* {: id="20210309181757-bu3d7mk"}按照操作数个数分：一元运算符（单目运算符）、二元运算符（双目运算符）、三元运算符 （三目运算符）
  {: id="20210309181757-jsa4wzb"}

  一元运算符：操作数只有一个
  例如：正号（+）  +a
  负号（-）  -a
  自增自减   ++i  i++
  逻辑非：   !true
  {: id="20210309181757-2gmb8ej"}

  二元运算符：操作数有两个
  例如：加法：a+b
  减法：a-b
  大于：a>b
  逻辑与：a&b
  三元运算符：条件 ? 结果1 ： 结果2
  {: id="20210309181757-s2io2vr"}
{: id="20210309181757-jt3c2hi"}

### 2.10.1 算术运算符
{: id="20210309181757-xdra7sf"}

|  算术运算符  |            符号解释            |
| :-----------: | :-----------------------------: |
|      `+`      | 加法运算，字符串连接运算，正号 |
|      `-`      |         减法运算，负号         |
|      `*`      |            乘法运算            |
|      `/`      | 除法运算，整数/整数结果还是整数 |
|      `%`      | 求余运算，余数的符号只看被除数 |
| `++` 、  `--` |          自增自减运算          |
{: id="20210309181757-ornpsck"}

#### 1、加减乘除模
{: id="20210309181757-dafricv"}

（==一个数字取模的正负号取决于第一个数的正负==）
{: id="20210309181757-cywwv9r"}

```java
public class OperatorDemo01 {
	public static void main(String[] args) {
		int a = 3;
		int b = 4;
		
		System.out.println(a + b);// 7
		System.out.println(a - b);// -1
		System.out.println(a * b);// 12
		System.out.println(a / b);// 计算机结果是0，为什么不是0.75呢？
		System.out.println(a % b);// 3
        
        System.out.println(5%2);//1
		System.out.println(5%-2);//1
		System.out.println(-5%2);//-1
		System.out.println(-5%-2);//-1		
		//商*除数 + 余数 = 被除数
		//5%-2  ==>商是-2，余数时1    (-2)*(-2)+1 = 5
		//-5%2  ==>商是-2，余数是-1   (-2)*2+(-1) = -4-1=-5
	}
}
```
{: id="20210309181757-j1w8iw9"}

#### 2、“+”号的两种用法
{: id="20210309181757-jptxlov"}

* {: id="20210309181757-m8n5bcp"}第一种：对于`+`两边都是数值的话，`+`就是加法的意思
  {: id="20210309181757-cu9j5ik"}
* {: id="20210309181757-unbafvi"}第二种：对于`+`两边至少有一边是字符串得话，`+`就是拼接的意思
  {: id="20210309181757-wnoa454"}
{: id="20210309181757-4ptwmln"}

```java
public class OperatorDemo02 {
	public static void main(String[] args) {
		// 字符串类型的变量基本使用
		// 数据类型 变量名称 = 数据值;
		String str1 = "Hello";
		System.out.println(str1); // Hello
		
		System.out.println("Hello" + "World"); // HelloWorld
		
		String str2 = "Java";
		// String + int --> String
		System.out.println(str2 + 520); // Java520
		// String + int + int
		// String		+ int
		// String
		System.out.println(str2 + 5 + 20); // Java520
	}
}
```
{: id="20210309181757-o93am40"}

#### 3、自加自减运算
{: id="20210309181757-jo11i1u"}

**理解：**`++`  **运算，变量自己的值加1**。反之，`--` 运算，变量自己的值减少1，用法与`++` 一致。
{: id="20210309181757-110naaa"}

1、单独使用
{: id="20210309181757-qy0doga"}

* {: id="20210309181757-icxo0zo"}变量在单独运算的时候，变量`前++`和变量`后++`，变量的是一样的；
  {: id="20210309181757-by4b85o"}
* {: id="20210309181757-6oxgxit"}变量`前++`   ：例如 `++a` 。
  {: id="20210309181757-moh5ihk"}
* {: id="20210309181757-zfo5byp"}变量`后++`   ：例如 `a++` 。
  {: id="20210309181757-jy8g955"}
{: id="20210309181757-tkcl8hu"}

```java
public class OperatorDemo3 {
	public static void main(String[] args) {
		// 定义一个int类型的变量a
		int a = 3;
		//++a;
		a++;
        // 无论是变量前++还是变量后++，结果都是4
		System.out.println(a);
	}
}
```
{: id="20210309181757-8wldz7k"}

2、复合使用
{: id="20210309181757-ujg4cpp"}

* {: id="20210309181757-sne9erb"}和`其他变量放在一起使用`或者和`输出语句放在一起使用`，`前++`和`后++`就产生了不同。
  {: id="20210309181757-yomd9p9"}
{: id="20210309181757-apd4mp4"}

- {: id="20210309181757-rhajww1"}变量`前++` ：变量先自身加1，然后再取值。
  {: id="20210309181757-8p17ofn"}
- {: id="20210309181757-iwcbiu2"}变量`后++` ：变量先取值，然后再自身加1。
  {: id="20210309181757-n9kqd3t"}
{: id="20210309181757-caa7ynn"}

```java
public class OperatorDemo03 {
	public static void main(String[] args) {
		// 其他变量放在一起使用
		int x = 3;
		//int y = ++x; // y的值是4，x的值是4，
		int y = x++; // y的值是3，x的值是4
		
		System.out.println(x);
		System.out.println(y);
		System.out.println("==========");
        
		// 和输出语句一起
		int z = 5;
		//System.out.println(++z);// 输出结果是6，z的值也是6
		System.out.println(z++);// 输出结果是5，z的值是6
		System.out.println(z);
        
        int a = 1;
        a = a++;//(1)先取a的值“1”放操作数栈(2)a再自增,a=2(3)再把操作数栈中的"1"赋值给a,a=1

        int i = 1;
        int j = i++ + ++i * i++;
        /*
        从左往右加载
        (1)先算i++
        ①取i的值“1”放操作数栈
        ②i再自增 i=2
        （2）再算++i
        ①i先自增 i=3
        ②再取i的值“3”放操作数栈
        （3）再算i++
        ①取i的值“3”放操作数栈
        ②i再自增 i=4
        （4）先算乘法
        用操作数栈中3 * 3 = 9，并把9压会操作数栈
        （5）再算求和
        用操作数栈中的 1 + 9 = 10
        （6）最后算赋值
        j = 10
        */
	} 
}
```
{: id="20210309181757-yz0dc24"}

* {: id="20210309181757-w4jvgjj"}小结：（==两个数相加，和值会临时存在操作数栈上，然后操作数栈赋值给新的变量，前++，先++，再入栈，后++，先入栈，再自加==）
  {: id="20210309181757-gxybnu1"}
  * {: id="20210309181757-85m3254"}**++在前，先自加，后使用；**
    {: id="20210309181757-zfltyhn"}
  * {: id="20210309181757-3vt52ke"}**++在后，先使用，后自加。**
    {: id="20210309181757-qpzu4at"}
  {: id="20210309181757-pdg4i5g"}
{: id="20210309181757-x6yjn0p"}

#### 4、练习
{: id="20210309181757-cmjpowj"}

##### （1）获取一个四位数的个位，十位，百位，千位
{: id="20210309181757-p9iag56"}

```java
public class Test01 {
	public static void main (String [] args) {
		//1.定义一个四位数，例如1234
		int num = 1234;
        
		//2.通过运算操作求出个位，十位，百位，千位
		int ge = ？
		int shi = ？
		int bai = ？
		int qian = ？
		
		System.out.println(num + "这个四位数个位上的数字是：" + ge);
		System.out.println(num + "这个四位数十位上的数字是：" + shi);
		System.out.println(num + "这个四位数百位上的数字是：" + bai);
		System.out.println(num + "这个四位数千位上的数字是：" + qian);
	}
}
```
{: id="20210309181757-oat9sj5"}

##### （2）自增自减练习
{: id="20210309181757-w6vaeo2"}

判断如下代码的运行结果
{: id="20210309181757-46c8rp5"}

```java
	public static void main(String[] args){
		int i = 1;
		int j = i++;
		int k = i++ * ++j + ++i * j++;
		
		System.out.println("i = " + i);
		System.out.println("j = " + j);
		System.out.println("k = " + k);
	}
```
{: id="20210309181757-ykimtnn"}

```java
	public static void main(String[] args){
		int i = 1;
		int j = i++;
		int k = i++ * ++j + --i * j--;
		
		System.out.println("i = " + i);
		System.out.println("j = " + j);
		System.out.println("k = " + k);
	}
```
{: id="20210309181757-pqiov18"}

```java
	public static void main(String[] args){
		int i = 1;
		int j = ++i + i++ * ++i + i++;
		
		System.out.println("i = " + i);
		System.out.println("j = " + j);
	}
```
{: id="20210309181757-qrdy577"}

```java
public static void main(String[] args){
	int i = 0;
	int result = ++i/--i;
	System.out.println("result="+result);
}
```
{: id="20210309181757-2ek2lkp"}

### 2.10.2 赋值运算符
{: id="20210309181757-6t565tn"}

注意：所有的赋值运算符的=左边一定是一个变量（==赋值符号右侧的四种形式①常量赋值②变量赋值③表达式赋值④返回值赋值==）
{: id="20210309181757-n5zgxi6"}

| 赋值运算符 |                                      符号解释                                      |
| :--------: | :--------------------------------------------------------------------------------: |
|    `=`    |                          将符号右边的值，赋值给左边的变量                          |
|    `+=`    | 将符号**`左边的值`**和**`右边的值`**进行相加操作，最后将结果**`赋值给左边的变量`** |
|    `-=`    | 将符号**`左边的值`**和**`右边的值`**进行相减操作，最后将结果**`赋值给左边的变量`** |
|    `*=`    | 将符号**`左边的值`**和**`右边的值`**进行相乘操作，最后将结果**`赋值给左边的变量`** |
|    `/=`    | 将符号**`左边的值`**和**`右边的值`**进行相除操作，最后将结果**`赋值给左边的变量`** |
|    `%=`    | 将符号**`左边的值`**和**`右边的值`**进行取余操作，最后将结果**`赋值给左边的变量`** |
{: id="20210309181757-5jkuu0z"}

#### 1、基本赋值运算符课堂案例
{: id="20210309181757-38l7vo1"}

```java
public class OperatorDemo04 {
	public static void main(String[] args) {
		int a = 3;
		int b = 4;
		a = a + b; 
		System.out.println(a); // 7
		System.out.println(b); // 4	
	}
}
```
{: id="20210309181757-prnf0kd"}

#### 2、扩展赋值运算符课堂案例
{: id="20210309181757-w23etg1"}

```java
public class OperatorDemo04 {
	public static void main(String[] args) {
		int a = 3;
		int b = 4;
		b += a;// 相当于 b = b + a ; 
		System.out.println(a); // 3
		System.out.println(b); // 7	
		
		short s = 3;
		// s = s + 4; 代码编译报错，因为将int类型的结果赋值给short类型的变量s时，可能损失精度
		s += 4; // 代码没有报错
        //因为在得到int类型的结果后，JVM自动完成一步强制类型转换，将int类型强转成short
		System.out.println(s);
        
        int j = 1;
		j += ++j * j++;//相当于  j = j + (++j * j++);
		System.out.println(j);//5
	}
}
```
{: id="20210309181757-leg2c9y"}

* {: id="20210309181757-lj9n4hf"}扩展赋值运算符在**将最后的结果赋值给左边的变量前，都做了一步强制类型转换**。
  {: id="20210309181757-407ygtv"}
{: id="20210309181757-nokt7vr"}

#### 3、练习
{: id="20210309181757-sahzjdq"}

交换两个变量的值
int m = 1;
int n = 2;
{: id="20210309181757-0akl9oe"}

```java
int m = 1;
int n = 2;
int temp = m;
m = n;
n = temp;
```
{: id="20210309181757-avurxd5"}

### 2.10.3 关系运算符/比较运算符
{: id="20210309181757-sf5ltot"}

| 关系运算符 |                              符号解释                              |
| :--------: | :-----------------------------------------------------------------: |
|    `<`    |     比较符号左边的数据是否小于右边的数据，如果小于结果是true。     |
|    `>`    |     比较符号左边的数据是否大于右边的数据，如果大于结果是true。     |
|    `<=`    | 比较符号左边的数据是否小于或者等于右边的数据，如果大于结果是false。 |
|    `>=`    | 比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是false。 |
|    `==`    |             比较符号两边数据是否相等，相等结果是true。             |
|   `！=`   |         不等于符号 ，如果符号两边的数据不相等，结果是true。         |
{: id="20210309181757-neqhsgy"}

* {: id="20210309181757-j96k4kz"}比较运算符，是两个数据之间进行比较的运算，运算结果一定是boolean值`true`或者`false` 。
  {: id="20210309181757-bbhr2b7"}
* {: id="20210309181757-bynsjod"}其中>,<,>=,<=不支持boolean，String类型，==和!=支持boolean和String。<!--（String比较大小使用.equal）-->
  {: id="20210309181757-exvyq7q"}
{: id="20210309181757-4dj0hb3"}

```java
public class OperatorDemo05 {
	public static void main(String[] args) {
		int a = 3;
		int b = 4;

		System.out.println(a < b); // true
		System.out.println(a > b); // false
		System.out.println(a <= b); // true
		System.out.println(a >= b); // false
		System.out.println(a == b); // false
		System.out.println(a != b); // true
	}
}
```
{: id="20210309181757-y6xmd6l"}

#### 练习：判断如下程序的运行结果
{: id="20210309181757-zy1v4ar"}

```java
public static void main(String[] args){
	int a = 1;
	int b = 2;
	int c = 0;
	boolean flag = false;
	if(flag=true){
		c = a++ + b;
	}

	if(flag=false){
		c = ++a - b;
	}
	System.out.println("a = " + a);
	System.out.println("b = " + b);
	System.out.println("c = " + c);
}	
```
{: id="20210309181757-joa2iv5"}

### 2.10.4 逻辑运算符
{: id="20210309181757-et97sxs"}

* {: id="20210309181757-5jt1tmg"}逻辑运算符，是用来连接两个布尔类型结果的运算符（`!`除外），运算结果一定是boolean值`true`或者`false`(==不能在if表达式写赋值符号==)
  {: id="20210309181757-sj8504y"}
{: id="20210309181757-mkcvs46"}

| 逻辑运算符 |   符号解释   |               符号特点               |
| :--------: | :----------: | :----------------------------------: |
|    `&`    |    与，且    |          有`false`则`false`          |
|     `     |      `      |                  或                  |
|    `^`    |     异或     |     相同为`false`，不同为`true`     |
|    `!`    |      非      | 非`false`则`true`，非`true`则`false` |
|    `&&`    | 双与，短路与 |      左边为false，则右边就不看      |
|     `     |              |                  `                  |
{: id="20210309181757-pthbtjo"}

####　1、课堂案例
{: id="20210309181757-hpng520"}

```java
public class OperatorDemo06 {
	public static void main(String[] args) {
		int a = 3;
		int b = 4;
		int c = 5;

		// & 与，且；有false则false
		System.out.println((a > b) & (a > c)); 
		System.out.println((a > b) & (a < c)); 
		System.out.println((a < b) & (a > c)); 
		System.out.println((a < b) & (a < c)); 
		System.out.println("===============");
		// | 或；有true则true
		System.out.println((a > b) | (a > c)); 
		System.out.println((a > b) | (a < c)); 
		System.out.println((a < b) | (a > c));
		System.out.println((a < b) | (a < c));
		System.out.println("===============");
		// ^ 异或；相同为false，不同为true
		System.out.println((a > b) ^ (a > c));
		System.out.println((a > b) ^ (a < c)); 
		System.out.println((a < b) ^ (a > c)); 
		System.out.println((a < b) ^ (a < c)); 
		System.out.println("===============");
		// ! 非；非false则true，非true则false
		System.out.println(!false);
		System.out.println(!true);
	}
}
```
{: id="20210309181757-9thh142"}

####　 2、&&和&区别，||和|区别
{: id="20210309181757-53xhhk3"}

* {: id="20210309181757-pdr1h86"}**`&&`和`&`**区别：
  {: id="20210309181757-fi8pq0r"}
  * {: id="20210309181757-ub87293"}`&&`和`&`结果一样，`&&`有短路效果，左边为false，右边不执行；`&`左边无论是什么，右边都会执行。
    {: id="20210309181757-h8il7p4"}
  {: id="20210309181757-puotq5a"}
* {: id="20210309181757-r27sysw"}**`||`和`|`**区别：
  {: id="20210309181757-ihgov4i"}
  * {: id="20210309181757-2tsi4k5"}`||`和`|`结果一样，`||`有短路效果，左边为true，右边不执行；`|`左边无论是什么，右边都会执行。
    {: id="20210309181757-vounwr7"}
  {: id="20210309181757-0tylytn"}
{: id="20210309181757-ladzgb8"}

#### 3、面试题1
{: id="20210309181757-zt0ju1w"}

![1561431178935](img/1561431178935.png)
{: id="20210309181757-3gvftb9"}

```java
public class LogicExer1{
	public static void main(String[] args){
		int x = 1;
		int y = 1;

		//x==2 ,x++  false  x = 2 左边为false
		//右边继续
		//++y  y==2  y=2  y==2成立  右边为true
		//false & true 结果false
		if(x++==2 & ++y==2){
			x =7;
		}
		System.out.println("x="+x+",y="+y);//x=2,y=2
	}
}
```
{: id="20210309181757-3y2xlyo"}

```java
public class LogicExer2{
	public static void main(String[] args){
		int x = 1,y = 1;

		//x==2,x++  左边条件为false，x=2
		//因为短路与，右边不算
		//false && ? 结果是false
		if(x++==2 && ++y==2){
			x =7;
		}
		System.out.println("x="+x+",y="+y);//x=2,y=1
	}
}
```
{: id="20210309181757-kx05znm"}

```java
public class LogicExer3{
	public static void main(String[] args){
		int x = 1,y = 1;

		//x==1,x++  左边为true，x=2
		//因为是逻辑与,右边继续  
		//++y, y==1  y=2 右边为false
		//条件true | false，最终为true
		if(x++==1 | ++y==1){
			x =7;
		}
		System.out.println("x="+x+",y="+y);//x=7,y=2
	}
}	
```
{: id="20210309181757-29gdzip"}

```java
public class LogicExer4{
	public static void main(String[] args){
		int x = 1,y = 1;

		//x==1,x++  左边为true，x=2
		//因为是短路或，左边为true，右边就不看了
		//整个条件为true
		if(x++==1 || ++y==1){
			x =7;
		}
		System.out.println("x="+x+",y="+y);//x=7,y=1

	}
}
```
{: id="20210309181757-p2iug3r"}

#### 4、面试题2
{: id="20210309181757-x12isjr"}

![1561431208735](img/1561431208735.png)
{: id="20210309181757-uybod3y"}

```java
public class LogicExer5{
	public static void main (String []  args)  {
		boolean x = true;
		boolean y = false;
		short z = 42;
		
		//如果if((z++==42)&&(y==true))条件成立，执行z++，不成立，就不执行z++
		//左边的条件：z==42,z++  z==42成立,z++变成43
		//中间虽然是短路与，因为左边现在是true,右边还要看
		//右边 y==true   不成立
		//true && false 结果为false
		if((z++==42)&&(y==true))	z++;
	
		//左边为x=false,赋值  结果就为false
		//中间虽然为短路或，因为左边是false,右边继续看
		//++z,z==45  ++z变成44，z==45是否成立，不成立
		//false || false  结果为false
		if((x=false) || (++z==45))  z++;

		System. out.println("z="+z);//44
	}
}
```
{: id="20210309181757-k7ip9w4"}

```java
class  Test4_2  {
	public static void main (String []  args)  {
		boolean x = true;
		boolean y = false;
		short z = 42;
		
		//如果if(y=true)条件成立，接着判断if((z++==42)&&(y==true))	z++;	
		//如果不成立，if((z++==42)&&(y==true))	z++;	不看的
		/*
		if(y = true)
				
		if((z++==42)&&(y==true))	z++;	
		
		if((x=false) || (++z==45))  z++;
		*/
		
		//标准
		//y=true赋值，y就被修改为true,if(true)成立
		if(y=true){
			//左边：z==42,z++  成立,z变成43
			//&&短路与，不满足短路的情况，右边继续
			//y==true 成立
			//true && true，结果为true
			if((z++==42)&&(y==true)){
				//z++变成44
				z++;
			}
		}
		//左边：x=false不成立
		//中间虽然是短路或，但是没满足短路的情况，右边继续
		//++z,z==45  ++z变成45，z==45成立
		if((x=false) || (++z==45)){
			//z++，变成46
			z++;
		}
		System. out.println("z="+z);//46
	}
}
```
{: id="20210309181757-1rsxltc"}

### 2.10.5 条件运算符
{: id="20210309181757-55v21qk"}

- {: id="20210309181757-utjeqjm"}条件运算符格式：
  {: id="20210309181757-05jyhu0"}
{: id="20210309181757-m9i8t15"}

```java
条件表达式？结果1：结果2
```
{: id="20210309181757-df00dxf"}

- {: id="20210309181757-29f2cpn"}条件运算符计算方式：
  {: id="20210309181757-e534krf"}
  - {: id="20210309181757-4ntof97"}条件判断的结果是true，条件运算符整体结果为结果1，赋值给变量。
    {: id="20210309181757-fh6lay1"}
  - {: id="20210309181757-b28qzp5"}判断条件的结果是false，条件运算符整体结果为结果2，赋值给变量。
    {: id="20210309181757-9se3rpd"}
  {: id="20210309181757-gs39yvu"}
{: id="20210309181757-pbui4sn"}

```java
public static void main(String[] args) {
    int i = (1==2 ? 100 : 200);
    System.out.println(i);//200
    int j = (3<=4 ? 500 : 600);
    System.out.println(j);//500
}
```
{: id="20210309181757-3hbf2my"}

#### 练习
{: id="20210309181757-bya2ft7"}

1、声明三个整型的变量,a,b,c,要求找出最大值
2、声明一个整型的变量，判断它是正数还是负数，还是0
{: id="20210309181757-t6qm0uk"}

### 2.10.6  位运算符
{: id="20210309181757-sm8i8kk"}

（==位运算效率最高，但是只能运算二进制的整数==）
{: id="20210309181757-tyt6aj6"}

| 位运算符 |                    符号解释                    |
| :------: | :--------------------------------------------: |
|   `&`   |        按位与，当两位相同时为1时才返回1        |
|    `    |                       `                       |
|   `~`   | 按位非，将操作数的每个位（包括符号位）全部取反 |
|   `^`   |    按位异或。当两位相同时返回0，不同时返回1    |
|   `<<`   |                   左移运算符                   |
|   `>>`   |                   右移运算符                   |
|  `>>>`  |                无符号右移运算符                |
{: id="20210309181757-rwzu2nd"}

左移：<<
{: id="20210309181757-5npoteh"}

​	运算规则：左移几位就相当于乘以2的几次方
{: id="20210309181757-d3ri9nw"}

右移：>>
{: id="20210309181757-aunt0l2"}

​	运算规则：右移几位就相当于除以2的几次方
{: id="20210309181757-0bw67c2"}

无符号右移：>>>
{: id="20210309181757-p1bovso"}

​	==运算规则：往右移动后，左边空出来的位直接补0，不看符号位==
{: id="20210309181757-7zgcxjo"}

> 注意：当左移的位数n超过该数据类型的总位数时，相当于左移（n-总位数）
> {: id="20210309181757-75wvbbn"}
>
> byte,short,char在计算时按照int类型处理
> {: id="20210309181757-idllk45"}
{: id="20210309181757-gnmv74s"}

按位与：&
{: id="20210309181757-hd3p68r"}

​	运算规则：
{: id="20210309181757-hlmfkn0"}

​		1 & 1 结果为1
{: id="20210309181757-qfv99hy"}

​		1 & 0 结果为0
{: id="20210309181757-aaifixd"}

​		0 & 1 结果为0
{: id="20210309181757-m8wg6ek"}

​		0 & 0 结果为0
{: id="20210309181757-33tapnz"}

按位或：|
{: id="20210309181757-rhp00rs"}

​	运算规则：
{: id="20210309181757-atq87ot"}

​		1 | 1 结果为1
{: id="20210309181757-wwodt31"}

​		1 | 0 结果为1
{: id="20210309181757-raauz0i"}

​		0 | 1 结果为1
{: id="20210309181757-eydxpiq"}

​		0 & 0 结果为0
{: id="20210309181757-51pu5y7"}

按位异或：^
{: id="20210309181757-txaepqa"}

​	运算规则：
{: id="20210309181757-ln24i6g"}

​		1 ^ 1 结果为0
{: id="20210309181757-4pathyn"}

​		1 ^ 0 结果为1
{: id="20210309181757-exvfvmh"}

​		0 ^ 1 结果为1
{: id="20210309181757-a3jfry2"}

​		0 ^ 0 结果为0
{: id="20210309181757-3uvbum4"}

按位取反：~
{: id="20210309181757-nnsatay"}

​	 运算规则：~0就是1
{: id="20210309181757-07phhmj"}

​			   ~1就是0
{: id="20210309181757-jc6dg35"}

> 如何区分&,|,^是逻辑运算符还是位运算符？
> {: id="20210309181757-rvrzhdj"}
>
> 如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就位运算符。
> {: id="20210309181757-3y4ebr6"}
{: id="20210309181757-6d30oo8"}

### 2.10.7 运算符优先级
{: id="20210309181757-xlv1ud3"}

![1553858424335](img/1553858424335.png)
{: id="20210309181757-h7chk61"}

提示说明：
{: id="20210309181757-4qooi5a"}

（1）表达式不要太复杂
{: id="20210309181757-prehail"}

（2）先算的使用()
{: id="20210309181757-g4j9rpm"}

大体的排序：算术->位-->比较-->逻辑-->三元-->赋值
{: id="20210309181757-17y86oy"}


{: id="20210309181757-cite0s5" type="doc"}
